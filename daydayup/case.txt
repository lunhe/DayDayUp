1 请求瞬间全部到，导致队列阻塞，观察阻塞后情况，等待超时后情况，任务是否在执行，task是否被cancel，主动cancel是否成功

2 请求间或到达，可能造成队列阻塞，也可能一个批次可能够执行，观察能够执行时，执行超时，超时后是否会引发中断异常，没有造成中断异常的，超时后的future状态，以及主动cancel是否完成



1 昨天的日志来看：没有发生死锁，因此大概率队列没有被阻塞
2 昨日的日志中部分返回提示：说明部分任务确实被主动cancel（是否cancel成功另说）


case1 如果直接进入死锁，最后超时导致future1无法执行，那么阻塞后面所有的请求，大概率全部失败，小部分可能因为很晚到达形成future2，在昨天的测试下，future2一定不会阻塞，future2继续执行，但是future2会去消耗队列中剩下的所有任务，包括future1没有消耗的。这样会导致所有的任务依然被执行。并且引发future2的接口超时（但此时的超时后的主动cancel很可能因为中断未检查，不会stop任务线程）
----future结束时保证队列清空的必要性

case2 1秒钟过去后或者队列满的瞬间并没有死锁，future1执行了60个请求，造成future1超时，同样因为没有检查中断，future的主动cancel即使成功，任务也将继续完成。这样剩余较少的请求是可以成功的。



case1  请求被队列阻塞，导致后面所有请求都挂在一个future上，直到future超时，超时异常被捕获后，future会被第一个超时的请求线程直接cancel，然后该请求线程返回超时提示，同时导致队列无法消费，不被清空。在任务被cancel之前，future超时之后的请求线程都会报告超时异常，进入超时逻辑，但只有一个请求线程尝试cancel会成功，其余则进入检查future是否结束逻辑，并返回future结束逻辑。而剩余请求陆续超时，超时发现future已经被cancel，不再报超时异常，而报告cancellationexception。造成返回为null

case2  请求没有阻塞，但是任务执行时间过长，导致future超时，余下的同case1.唯一区别的是，future的cancel操作无法真的stop任务。所以任务会继续执行完成。造成接口返回失败或异常，但实际成功。（我们测试中大多数是这种情况）




1 阻塞队列问题
2 异常后任务cancel问题
3 异常后的队列清空问题
4 超时后异常逻辑问题