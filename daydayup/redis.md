###性能优化

优化的理念：

```
	1 减少指令发送的网络开销（尽量合并发送类似指令，使用批处理处理一个slot下的数据）
	2 降低CPU占用高（O（n））的指令频率（少用）或者数据范围（降低n值，有文章建议小于300）。这一点的根本原因是redis单线程，同时只能占用一个cpu核，应该充分和无压力的利用cpu缓存，以此提高响应。
```

优化的理念：

```
	1 首先代码的执行链观察是否延迟出现在redis
	2 使用redis的性能分析指令，获得当前机器的基准性能，然后在相当的服务器获取基准性能，以此确定是否是机器本身的问题。
	3 如果是网络问题，那么部署在redis机器上的所有服务都会存在网络延迟，一般小概率且相对容易发现
	4 打开redis的慢日志，如果慢日志过多，则可能猜测业务中使用了一些复杂度较高的操作，这是应该在业务中避免的。
	5 分析bigkey,bigkey会影响redis的内存申请和释放效率
		避免bigKey
		开启lazyfree-lazy-user-del = yes，这样删除后的内存释放操作会在后台的其他线程执行。
	6 集中过期，大量的key集中到期，redis在主线中执行清理操作，该操作会循环执行，直到过期key低于25%或者单次执行时间超过25ms。需要注意到是这种才做不会出现慢日志中。
		避免集中过期
		为高频业务的过期加随机值
		开启延迟删除机制
	7 由于配置了redis的内存上线，导致接近上限时，每次的插入操作都需要使用约定的清除策略去删除一些历史缓存，导致变慢。如果删除中包含了bigkey则更加严重。
		避免bigKey
		开启延迟删除策略
		集群分散压力
		使用随机清除策略
	8 fork消耗，当redis需要RDB（默认开启，在指定间隔备份redis数据）或者AOF（默认关闭,通过每秒记录日志来持久化数据）时，主进程会fork一个子进程去完成，主进程会拷贝整个实例内存给子进程，当实例过大会导致阻塞。
		控制实例的大小
		约束同步时间
		非必要可以关闭持久化
	9 开启了操作系统的大页机制。（通常app向操作系统申请的一个页位4K，但现在操作系统为了降低app的声请次数，可以直接生申请2M的内存，这意味会降低申请效率）
		场景：主进程fork子进程持久化，子进程在持久化的同时，主进程收到客户端的操作。此时主进程不会直接修改key的值，而是将key对应的值复制到临时内存，然后修改，以此保证子进程得到的是一个确定时刻的系统快照
		当主进程copy时，会申请新的内存，如果存在大页机制，则会降低效率
		建议，对于redis服务器，关闭此功能
		避免bigkey
		
```


使用hmset批量设置值


https://blog.csdn.net/weixin_39526415/article/details/111964696?spm=1000.2123.3001.4430

https://blog.csdn.net/weixin_44018338/article/details/102740395

redis特点
```
	队列+单线程出列客户端请求。可以同时处理很多的客户端链接，但同时只处理一个指令
	完全基于内存
	

```

###设计感悟

```

	针对redis是单线程，无法支撑频繁的O（n）操作的情况，一般的做法是，构建主从集群，将一些耗时的操作放到从。
	
	针对一个请求响应变慢的应用，一般地，需要全链路观察正真拖慢响应的服务。
	然而不一定每个服务都有现成的耗时日志可供分析，并且为每个服务的出入口增加日志观察耗时，也不总是那么方便。
	既然这样，有没有可以能在设计之初规划好一个不同服务的标准出入口，并在这里增加检测。就像是主板上的总线，消息总是要经过总线才能到达不同的设备。

```