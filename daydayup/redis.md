###性能优化

优化的理念：

```
	1 减少指令发送的网络开销（尽量合并发送类似指令，使用批处理处理一个slot下的数据）
	2 降低CPU占用高（O（n））的指令频率（少用）或者数据范围（降低n值，有文章建议小于300）。这一点的根本原因是redis单线程，同时只能占用一个cpu核，应该充分和无压力的利用cpu缓存，以此提高响应。
```

优化的理念：

```
	1 首先代码的执行链观察是否延迟出现在redis
	2 使用redis的性能分析指令，获得当前机器的基准性能，然后在相当的服务器获取基准性能，以此确定是否是机器本身的问题。
	3 如果是网络问题，那么部署在redis机器上的所有服务都会存在网络延迟，一般小概率且相对容易发现
	4 打开redis的慢日志，如果慢日志过多，则可能猜测业务中使用了一些复杂度较高的操作，这是应该在业务中避免的。
	5 分析bigkey,bigkey会影响redis的内存申请和释放效率
		避免bigKey
		开启lazyfree-lazy-user-del = yes，这样删除后的内存释放操作会在后台的其他线程执行。
	6 集中过期，大量的key集中到期，redis在主线中执行清理操作，该操作会循环执行，直到过期key低于25%或者单次执行时间超过25ms。需要注意到是这种操作不会出现慢日志中。
		避免集中过期
		为高频业务的过期加随机值
		开启延迟删除机制
	7 由于配置了redis的内存上线，导致接近上限时，每次的插入操作都需要使用约定的清除策略去删除一些历史缓存，导致变慢。如果删除中包含了bigkey则更加严重。
		避免bigKey
		开启延迟删除策略
		集群分散压力
		使用随机清除策略
	8 fork消耗，当redis需要RDB（默认开启，在指定间隔备份redis数据）或者AOF（默认关闭,通过每秒记录日志来持久化数据）时，主进程会fork一个子进程去完成，主进程会拷贝整个实例内存给子进程，当实例过大会导致阻塞。
		控制实例的大小
		约束同步时间
		非必要可以关闭持久化
	9 开启了操作系统的大页机制。（通常app向操作系统申请的一个页位4K，但现在操作系统为了降低app的声请次数，可以直接生申请2M的内存，这意味会降低申请效率）
		场景：主进程fork子进程持久化，子进程在持久化的同时，主进程收到客户端的操作。此时主进程不会直接修改key的值，而是将key对应的值复制到临时内存，然后修改，以此保证子进程得到的是一个确定时刻的系统快照
		当主进程copy时，会申请新的内存，如果存在大页机制，则会降低效率
		建议，对于redis服务器，关闭此功能
		避免bigkey
		
```


使用hmset批量设置值


https://blog.csdn.net/weixin_39526415/article/details/111964696?spm=1000.2123.3001.4430

https://blog.csdn.net/weixin_44018338/article/details/102740395

redis特点
```
	队列+单线程出列客户端请求。可以同时处理很多的客户端链接，但同时只处理一个指令
	完全基于内存
	

```

###设计感悟

```

	针对redis是单线程，无法支撑频繁的O（n）操作的情况，一般的做法是，构建主从集群，将一些耗时的操作放到从。
	
	针对一个请求响应变慢的应用，一般地，需要全链路观察正真拖慢响应的服务。
	然而不一定每个服务都有现成的耗时日志可供分析，并且为每个服务的出入口增加日志观察耗时，也不总是那么方便。
	既然这样，有没有可以能在设计之初规划好一个不同服务的标准出入口，并在这里增加检测。就像是主板上的总线，消息总是要经过总线才能到达不同的设备。

```


###Raft协议
角色：leader，follower，Candidate

term：选举周期，保证一个选举周期内只有一个leader，约束term异常的节点。（原则是：term交小的节点退回到follower状态，并同步大的term值）

选举：每个follower节点在无法与leader通信时，的每个term都随机启动一个定时器，每个term的follower只有一张投票权，将自己更新为Candidate并向其他follower发送选举请求。获得(2n+1)/2 的选举就可以成为新的leader。如果在一个term同时中存在多个Candidate，要么有一个升级为leader，要么所有的Candidate票数都不会过半，这将直接开启下一个term，重新选举。

一致性：一致性算法都采用同步操作日志进行数据同步。leader负责所有客户端交互，leader通知follower同步更新log，并等待ack。保证指令的有效和操作顺序。leader只需要收到(2n+1)/2 的ack就会将该日志设置为已提交。

安全性：使用term保证被选举出来的leader一定是包含之前已经提交的log的。




###vlan网络
http://www.qianjia.com/html/2019-03/19_329607.html
vlan：虚拟子网。（使用端口划分的静态子网，使用终端mac，用户，ip划分的动态子网）
vlan内通信：直接使用直连的二层交换机，（夸交换机则使用trunk link（汇聚连接）通信）
vlan间通信：使用带有转发功能的三层交换机

二层交换机：工作在数据链路层（只能处理mac地址），使用mac地址直接通信，速度快。
三层交换机（简单路由+二层交换机）：工作在网络层（可以识别IP地址），使用IP转发报文，使用二层的物理硬件分发报文。


###redis-RDB-AOF

Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。
RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。
Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。
AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。
Redis 针对 AOF文件大的问题，提供重写的瘦身机制。
若只打算用Redis 做缓存，可以关闭持久化。
若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB。

rewrite机制：aof里存放了所有的redis 操作指令，当aof文件达到一定条件或者手动
bgrewriteaof命令都可以触发rewrite。
rewrite之后aof文件会保存keys的最后的状态，清除掉之前冗余的，来缩小这个文件。

自动触发的条件：
 long long growth =(server.appendonly_current_size*100/base) - 100;
 if (growth >=server.auto_aofrewrite_perc)

在配置文件里设置过：
auto-aof-rewrite-percentage 100 （当前写入日志文件的大小超过上一次rewrite之后的文件大小的百分之100时就是2倍时触发Rewrite）

